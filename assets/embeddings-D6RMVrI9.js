function p(e){return(e||"").toLowerCase().replace(/[^a-z0-9\s]/g," ").replace(/\s+/g," ").trim()}function m(e){const n=p(e);return n?n.split(" "):[]}function M(e){const n=e.map(f=>m(f)),c=new Map;for(const f of n){const i=new Set;for(const s of f)i.has(s)||(i.add(s),c.set(s,(c.get(s)||0)+1))}const r=Array.from(c.keys()).sort(),a=Math.max(1,e.length),g=r.map(f=>{const i=c.get(f)||0;return Math.log(1+a/(1+i))});function o(f){const i=m(f);if(i.length===0)return new Array(r.length).fill(0);const s=new Map;for(const t of i)s.set(t,(s.get(t)||0)+1);const l=new Array(r.length).fill(0);for(let t=0;t<r.length;t++){const d=r[t],h=s.get(d)||0;h>0&&(l[t]=h*g[t])}let u=0;for(const t of l)u+=t*t;if(u=Math.sqrt(u),u===0)return l;for(let t=0;t<l.length;t++)l[t]=l[t]/u;return l}return{vocabulary:r,idf:g,vectorize:o}}function w(e,n){if(!e||!n||e.length!==n.length)return 0;let c=0,r=0,a=0;for(let o=0;o<e.length;o++)c+=e[o]*n[o],r+=e[o]*e[o],a+=n[o]*n[o];if(r===0||a===0)return 0;const g=Math.sqrt(r)*Math.sqrt(a);return c/g}export{M as buildVectorizer,w as cosineSimilarity};
